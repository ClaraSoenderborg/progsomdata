# Question 8.1


## ii
### ex3

```fsharp
BEFORE: symbolic bytecode
>    compile "ex3";; 
val it: Machine.instr list =
  [LDARGS; CALL (1, "L1"); STOP; Label "L1"; INCSP 1; GETBP; CSTI 1; ADD;
   CSTI 0; STI; INCSP -1; GOTO "L3"; Label "L2"; GETBP; CSTI 1; ADD; LDI;
   PRINTI; INCSP -1; GETBP; CSTI 1; ADD; GETBP; CSTI 1; ADD; LDI; CSTI 1; ADD;
   STI; INCSP -1; INCSP 0; Label "L3"; GETBP; CSTI 1; ADD; LDI; GETBP; CSTI 0;
   ADD; LDI; LT; IFNZRO "L2"; INCSP -1; RET 0]
```
```
AFTER: 
24 LDARGS                 | void main (int n)   
19 CALL 1 5               
25 STOP                   
15 INCSP 1                |
13 GETBP                  |
0 CSTI 1                  | int i = 0
1 ADD                     |
0 CSTI 0                  |
12 STI                    | 
15 INCSP -1               
16 GOTO 43                | while (i<n)
13 GETBP                     |
0 CSTI 1                     | 
1 ADD                        | print i 
11 LDI                       | 
22 PRINTI                    |
15 INCSP -1               
13 GETBP                  |
0 CSTI 1                  |
1 ADD                     |
13 GETBP                  |
0 CSTI 1                  |
1 ADD                     | i = i + 1
11 LDI                    |
0 CSTI 1                  |
1 ADD                     |
12 STI                    |
15 INCSP -1
15 INCSP 0                |
13 GETBP                  |
0 CSTI 1                  | 
1 ADD                     |
11 LDI                    |
13 GETBP                  | i < n 
0 CSTI 0                  |
1 ADD                     |
11 LDI                    |
7 LT                      |
18 IFNZRO 18              |
15 INCSP -1              
21 RET 0 
```

### ex5

```fsharp
BEFORE: symbolic bytecode
>    compile "ex5";; 
val it: Machine.instr list =
  [LDARGS; CALL (1, "L1"); STOP; Label "L1"; INCSP 1; GETBP; CSTI 1; ADD;
   GETBP; CSTI 0; ADD; LDI; STI; INCSP -1; INCSP 1; GETBP; CSTI 0; ADD; LDI;
   GETBP; CSTI 2; ADD; CALL (2, "L2"); INCSP -1; GETBP; CSTI 2; ADD; LDI;
   PRINTI; INCSP -1; INCSP -1; GETBP; CSTI 1; ADD; LDI; PRINTI; INCSP -1;
   INCSP -1; RET 0; Label "L2"; GETBP; CSTI 1; ADD; LDI; GETBP; CSTI 0; ADD;
   LDI; GETBP; CSTI 0; ADD; LDI; MUL; STI; INCSP -1; INCSP 0; RET 1]
```

```
AFTER: 
24 LDARGS          | void main(int n) 
19 CALL 1 4         
25 STOP             
15 INCSP 1          
13 GETBP           | 
0 CSTI 1           | int r
1 ADD              |
13 GETBP              |
0 CSTI 0              | 
1 ADD                 | r = n
11 LDI                |
12 STI                |
15 INCSP -1 
15 INCSP +1       
13 GETBP            |
0 CSTI 0            |  access to n
1 ADD               |
11 LDI              |    
13 GETBP                |  
0 CSTI 2                | access to r
1 ADD                   |
19 CALL 2 39        | square(n, &r)
15 INCSP -1 
13 GETBP            |
0 CSTI 2            |  
1 ADD               | print r in block
11 LDI              |
22 PRINTI           |
15 INCSP -1 
15 INCSP -1 
13 GETBP            | 
0 CSTI 1            |
1 ADD               | print r
11 LDI              |
22 PRINTI           |
15 INCSP -1 
15 INCSP -1 
21 RET 0            | return from main
13 GETBP                | start of square function
0 CSTI 1                | access *rp
1 ADD                   |
11 LDI                  |
13 GETBP            |
0 CSTI 0            |
1 ADD               | access i
11 LDI              |
13 GETBP                |
0 CSTI 0                |
1 ADD                   | access i
11 LDI                  |
3 MUL               | i * i
12 STI              | *rp = i * i
15 INCSP -1 
15 INCSP 0
21 RET 1          | end of square function
```
The generated byte code shows that we have a nested scope by how it accesses the r variable inside the inner block and outside the inner block. When accessing and printing r inside the block, we add 2 to the base pointer, and outside of the block we add 1 to the base pointer to access r. It is therefore stored in different places in the stack. 

## Machinetrace of ex3
See ex3trace.txt







